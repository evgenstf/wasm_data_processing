**WebAssembly** *(сокр. WASM)* — технология запуска предварительно скомпилированного бинарного кода в браузере на стороне клиента. Впервые была представлена в 2015 году и на текущий момент поддерживается [большинством современных браузеров](https://caniuse.com/wasm).

Один из распространенный сценариев использования - предварительная обработка данных на стороне клиента перед отправкой файлов на сервер. В этой статье разберемся как это делается, обсудим сложности и минусы такого подхода.


# Устройство

Работа с WebAssembly начинается с предварительной сборки артефактов, необходÐ¸мых для запуска скомпилированного кода на стороне клиента. Их два: собственно сам бинарный файл и JavaScript прослойка, через которую можно вызывать методы из него.

Для сборки используется компилятор Emscripten, специально предназначенный для генерации WASM байт кода.

// здесь будет картинка с запуском Emscripten и получением артефактов

После сборки артефактов, их можно запускать на стороне клиента. Для этого сначала скачиваем их с сервера.

// здесь будет картинка со скрином файлов из хрома


А затем запускаем:
```
var wasmCode = new Uint8Array([...]);
var wasmModule = new WebAssembly.Module(wasmCode);
var wasmInstance = new WebAssembly.Instance(wasmModule, []);
console.log(wasmInstance.exports.fib(10));
```

В консоли можно увидеть результат:

// здесь будет картинка со скрином консоли хрома

Более подробно про начальные шаги в WebAssembly можно почитать [здесь](https://habr.com/ru/post/475778/) и [здесь](https://habr.com/ru/post/475778/).

// здесь будет рассказ про виртуальную машину и различные реализации запуска бинарного кода
// основные тезисы:
// -- нет регистров, только стек
// -- только простейшие типы: i32, i64, f32, f64

# Модель памяти

Память внутри виртуальной машины устроена достаточно просто:

![Модель памяти в WASM](https://habrastorage.org/webt/8m/ek/0l/8mek0lpn5fwccixe72pspomcxag.png)

Раздел, интересующий нас больше всего - куча, которая может выделяться при инициализации ВМ и иметь фиксированный размер или же быть динамической и увеличиваться по запросу.

Главный недостаток устройства памяти на мой взгляд -- невозможность уменьшить кучу после ее динамического увеличения. Таким образом, если аллоцировать некоторый объем памяти, он не будет освобожден до перезагрузки страницы.


# Обработка данных

Разберем ее на простом примере lz4-компрессии с помощью библиотеки, написанной на **C++**. Замечу, что на этом множество поддерживаемыÑ языков [не заканчивается](https://github.com/appcypher/awesome-wasm-langs).

Несмотря на простоту и некоторую синтетичность примера, это довольно полезная иллюстрация того, как работать с данными. Аналогичным образом над ними можно выполнять любые действия, для которых достаточно мощностей клиента: предобработка изображений перед отправкой на сервер, компрессия аудио, подсчет различных статистик и многое другое.

Весь код целиком можно найти [тут](https://github.com/evgenstf/wasm_data_processing).

## Пишем на С++

Используем [уже готовую реализацию](https://github.com/lz4/lz4) lz4. Тогда **main** файл будет выглядеть весьма лаконично:

```
#include "lz4.h"

extern "C" {

uint32_t compress_data(uint32_t* data, uint32_t data_size, uint32_t* result) {
  uint32_t result_size = LZ4_compress(
        (const char *)(data), (char*)(result), data_size);
  return result_size;
}

uint32_t decompress_data(uint32_t* data, uint32_t data_size, uint32_t* result, uint32_t max_output_size) {
  uint32_t result_size = LZ4_uncompress_unknownOutputSize(
        (const char *)(data), (char*)(result), data_size, max_output_size);
  return result_size;
}

}
```

Как можно видеть, в нем просто объявлены **внешние** (используя ключевое слово `extern`) функции, внутри вызывающие соответствующие методы из библиотеки с lz4.

Вообще говоря, в нашем случае этот файл бесполезен: можно сразу использовать нативный интерфейс из **lz4.h**. Однако в более сложных проектах (например, объединяющих функционал разных библиотек), удобно иметь такую общую точку входа с перечислением всех используемых функций.

Далее компилируем код используя уже упомянутый компилятор **Emscripten**:

```
em++ main.cpp lz4.c -o wasm_compressor.js \
    -s EXPORTED_FUNCTIONS='["_compress_data","_decompress_data"]' \
    -s EXTRA_EXPORTED_RUNTIME_METHODS='["cwrap"]' \
    -s WASM=1 -s ALLOW_MEMORY_GROWTH=1
```

Размер полученных артефактов оставляет желать лучшего:

```
$ du -hs wasm_compressor.*
112K    wasm_compressor.js
108K    wasm_compressor.wasm
```

Если открыть JS файл-прослойку, можно увидеть примерно следующее:

![код wasm_compress.js](https://habrastorage.org/webt/cs/8r/lx/cs8rlx29cgv0jg5ipr0l9uo5qic.png)

В ней много лишнего: от комментариев до сервисных функций, большая часть которых не используется. Ситуацию можно исправить добавлением флага `-O2`, [в Emscripten компиляторе он включает также оптимизацию js кода.](https://emscripten.org/docs/tools_reference/emcc.html#emcc-o2)

После этого js код выглядит более приятно:

![короткий код wasm_compress.js](https://habrastorage.org/webt/4b/hy/n7/4bhyn75qzzlw_v-clmtifvx0iza.png)

## Клиентский код

Нужно как-то вызвать обработчик на стороне клиента. Первым делом загрузим файл, предоставленный пользователем, через `FileReader`, хранить сырые данные будем в примитиве `Uint8Array`:

```
var rawData = new Uint8Array(fileReader.result);
```

Далее нужно передать загруженные данные в виртуальную машину. Для этого сначала аллоцируем нужное количество байт методом `_malloc`, затем скопируем туда JS массив методом `set`. Для удобства выделим эту логику в функцию `arrayToWasmPtr(array)`:

```
function arrayToWasmPtr(array) {
  var ptr = Module._malloc(array.length);
  Module.HEAP8.set(array, ptr);
  return ptr;
}
```

После загрузки данных в память виртуальной машины, нужно каким-то образом вызвать функцию из обработки. Но как эту функцию найти? Нам поможет метод `cwrap` - первым аргументом в нем указывается название искомой функции, вторым - воÐ·вращаемый тип, третьим - список с входными аргументами.

```
compressDataFunction = Module.cwrap('compress_data', 'number', ['number', 'number', 'number']);
```

И наконец нужно вернуть готовые байты из виртуальной машины. Для этого пишем еще одну функцию, копирующую их в JS массив посредством метода `subarray`

```
function wasmPtrToArray(ptr, length) {
  var array = new Int8Array(length);
  array.set(Module.HEAP8.subarray(ptr, ptr + length));
  return array;
}
```

Смотрим на результат:

// картинка с уменьшенным изображением

Вопросы:
// можно ли избавиться от лишних двух копирований?
// можно ли логировать в консоль из бинарного кода ?



# Область применения

// тут абзац о том, дÐ»я обработки чего еще wasm можно применять
--- Сжатие изображений
--- Кастомная архивация
--- Кастомное шифрование
--- Выделение лиц
--- Использование любых библиотек по обработке данных
