**WebAssembly** *(сокр. WASM)* — технология запуска предварительно скомпилированного бинарного кода в браузере на стороне клиента. Впервые была представлена в 2015 году и на текущий момент поддерживается [большинством современных браузеров](https://caniuse.com/wasm).

Один из распространенный сценариев использования - предварительная обработка данных на стороне клиента перед отправкой файлов на сервер. В этой статье разберемся как это делается, обсудим сложности и минусы такого подхода.


# Устройство

Работа с WebAssembly начинается с предварительной сборки артефактов, необходимых для запуска скомпилированного кода на стороне клиента. Их два: собственно сам бинарный файл и JavaScript прослойка, через которую можно вызывать методы из него.

Для сборки используется компилятор Emscripten, специально предназначенный для генерации WASM байт кода.

// здесь будет картинка с запуском Emscripten и получением артефактов

После сборки артефактов, их можно запускать на стороне клиента. Для этого сначала скачиваем их с сервера.

// здесь будет картинка со скрином файлов из хрома


А затем запускаем:
```
var wasmCode = new Uint8Array([...]);
var wasmModule = new WebAssembly.Module(wasmCode);
var wasmInstance = new WebAssembly.Instance(wasmModule, []);
console.log(wasmInstance.exports.fib(10));
```

В консоли можно увидеть результат:

// здесь будет картинка со скрином консоли хрома

Более подробно про начальные шаги в WebAssembly можно почитать [здесь](https://habr.com/ru/post/475778/) и [здесь](https://habr.com/ru/post/475778/).

// здесь будет рассказ про виртуальную машину и различные реализации запуска бинарного кода
// основные тезисы:
// -- нет регистров, только стек
// -- только простейшие типы: i32, i64, f32, f64

# Модель памяти

Память внутри виртуальной машины устроена достаточно просто:

![Модель памяти в WASM](https://habrastorage.org/webt/8m/ek/0l/8mek0lpn5fwccixe72pspomcxag.png)

Раздел, интересующий нас больше всего - куча, которая может выделяться при инициализации ВМ и иметь фиксированный размер или же быть динамической и увеличиваться по запросу.

Главный недостаток устройства памяти на мой взгляд -- невозможность уменьшить кучу после ее динамического увеличения. Таким образом, если аллоцировать некоторый объем памяти, он не будет освобожден до перезагрузки страницы.


# Обработка данных

## Пишем обработчик данных

Разберем обработку данных на примере уменьшения размера изображения с помощью open-source библиотеки, написанной на C++. Замечу, что на этом множество поддерживаемых языков не заканчивается. Фактически, подойдет любой LLVM-совместимый язык программирования. 

main файл будет выглядеть довольно лаконично:

```
#include "image_cropper/image_cropper.h"
#include <cstdint>

extern "C" {

uint32_t crop_image(uint8_t* source, uint32_t source_length, uint8_t* sink) {
  ImageCropper cropper("png");
  return cropper.crop(source, source_length, sink);
}

}
```

Как можно видеть, в нем мы просто объявляем **внешнюю** функцию (используя ключевое слово `extern`).

Далее компилируем код и получаем два необходимых артефакта:



// здесь будет скрин запуска компиляции и разбор флагов, которые при этом используются


Откроем JS файл-прослойку и видим что внутри:

// здесь js файл 

Как-то много лишнего. Такое происходит, потом что по-умолчанию emcc генерирует человекочитаемый код. Он конечно занимает слишком много места, поэтому добавляем флаг, сжимающий код до минимально возможного:

// здесь новый короткий js файл 

## Клиентский код

Дальше нужно как-то вызвать обработчик на стороне клиента. Первым делом загрузим файл, предоставленный пользователем, через `FileReader`, хранить сырые данные будем в примитиве `Uint8Array`:

```
var rawData = new Uint8Array(fr.result);
```

Далее нужно передать загруженные данные в виртуальную машину. Для этого сначала аллоцируем нужное количество байт методом `_malloc`, затем скопируем туда JS массив методом `set`. Для удобства выделим эту логику в функцию `sendArrayToWasm(array)`:

```
function sendArrayToWasm(array) {
  var ptr = Module._malloc(array.length)
  Module.HEAP8.set(array, ptr)
  return ptr
}
```

После загрузки данных в память виртуальной машины, нужно каким-то образом вызвать функцию из обработки. Но как эту функцию найти? Нам поможет метод `cwrap` - первым аргументом в нем указываем название искомой функции, вторым - возвращаемый тип, третьим - список с входными аргументами.

```
cropImageFunction = Module.cwrap('crop_image', 'number', ['number', 'number', 'number']);
```

И наконец нужно вернуть готовые байты из виртуальной машины. Для этого пишем еще одну функцию, копирующую их в JS массив посредством метода `subarray`

```
function extractArrayFromWasm(ptr, length) {
  var array = new Int8Array(length)
  var pos = ptr
  array.set(Module.HEAP8.subarray(pos, pos + length))
  return array
}
```

Смотрим на результат:

// картинка с уменьшенным изображением

Вопросы:
// можно ли избавиться от лишних двух копирований?
// можно ли логировать в консоль из бинарного кода ?



# Область применения

// тут абзац о том, для обработки чего еще wasm можно применять
--- Сжатие изображений
--- Кастомная архивация
--- Кастомное шифрование
--- Выделение лиц
--- Использование любых библиотек по обработке данных
